'''
MenOfPassion(A[], n) {
    sum <- 0;
    for i <- 1 to n - 1
        for j <- i + 1 to n
            sum <- sum + A[i] × A[j]; # 코드1
    return sum;
}
'''

n = int(input())        # 직접 적어보니, 7 입력 시 총 6번(n-1) 반복으로,
t = 0                   # 점차 1씩 줄여나가며 다한다는걸 알았다.(6+5+4+...+1)
for x in range(n-1):    # 그래서 반복문으로 자연수를 모두 더해주는 코드 작성.
    t += (x+1)
print(t)                # 하고 그걸 출력.
print(2)
# 최고차항에 관해, 앞자리에선 미미하게 늘어나긴 하지만 증가폭이 x=y보다 더 컸던 것으로 확인.
# 즉 O(n)보다 크므로 빅-오 표기법 중 O(n^2)로 표시할 수 있는 것을 확인함.
# 무엇보다 2중 반복문을 씀 ㅋ

'''
t = 0
for x in range(n-1):
    for y in range(x+1, n):
        t += 1

print(t)

드디어 문제다운 문제가 나온 듯하다. 심지어 n이 500,000까지라
단순 반복 카피로는 엄청난 숫자가 나와서 시간 초과가 걸리는듯함 ㅋㅋㅋㅋㅋㅋ
더 짧고 효율적으로, 정수로 연산되는 코드를 짜야할 것 같다.
800까지 갔는데도 연산량이 319,600번이 나오고, 다른 사람의 
시간과 코드량을 보니 단순 연산으로 가능한듯.
'''

'''
n = int(input())
print(n*(n-1)//2)
print(2)
아, n까지의 자연수의 총합을 저런 식으로도 나타낼 수 있다는걸 알았다.
어쨌건 반복으로 돌린 것보다 훨씬 효율적인듯
'''
