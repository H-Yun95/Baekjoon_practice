'''
어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 
각 자리수의 합을 의미한다. 어떤 자연수 M의 분해합이 N인 경우, M을 
N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 
된다. 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 
생성자가 없을 수도 있다. 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.

자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.
'''


def f(n):
    for x in range(1, n):        # 1부터 n-1까지 반복
        a = str(x)               # 하나씩 똑 띠게 문자열로 바까줌
        b = [int(a[x]) for x in range(len(a))]  # 그걸 하나씩 정수로 집어넣음
        if x + sum(b) == n:      # 그래서 x와 리스트 총합이 같다면
            return x             # 그 수 x를 리턴
    return 0  # 아니면 0 리턴


n = int(input())

print(f(n))
# 첫 제출 때, 해당사항 없으면 0 출력하라는걸 못보고 틀림.
# 그래서 함수 형식으로 바꿔 제출. 역시 시간이 오래 걸림.

# 브루트 포스 알고리즘에 미루어보았을 때... 1부터 n 사이 모든 수를
# 분해합 해봐야될거같은데... 그럼 계산이 너무 오래 걸리지 않나?

# a = str(123)
# b = [int(a[x]) for x in range(len(a))]
# print(a)
# print(b)

'''
숏코딩

n=int(input())
print([*[i for i in range(n)if n==i+sum(map(int,str(i)))],0][0])
'''

'''
시간이 매우 짧게 걸림(60ms)

a = input()   분해합을 문자로
l = len(a)    분해합의 길이
a = int(a)    그 문자를 정수로 변환

for i in range(max(1, a-(l*9)), a+1):        여기에 빠른 연산의 답이 있는거 같은데, a-(l*9) 이 부분이
    if i + sum((map(int, str(i)))) == a:     뭘 의미하는지 모르겠다. 그리고 이 부분을 보니, 부분합을 실행하는
        print(i)                             과정에서 꼭 리스트를 안돌려도 될듯.
        break
    if i==a :         이건 i가 a과 같은 값이 되어버린다면
        print(0)      0을 출력하기 위한 제동장치.
'''
