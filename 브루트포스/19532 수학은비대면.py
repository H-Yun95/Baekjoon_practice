'''
수현이는 4차 산업혁명 시대에 살고 있는 중학생이다. 코로나 19로 인해, 
수현이는 버추얼 학교로 버추얼 출석해 버추얼 강의를 듣고 있다. 수현이의 
버추얼 선생님은 문자가 2개인 연립방정식을 해결하는 방법에 대해 강의하고, 
다음과 같은 문제를 숙제로 냈다.

다음 연립방정식에서 
$x$와 
$y$의 값을 계산하시오.
 
ax + by = c
dx + ey = f

4차 산업혁명 시대에 숙제나 하고 앉아있는 것보다 버추얼 친구들을 만나러 
가는 게 더 가치있는 일이라고 생각했던 수현이는 이런 연립방정식을 풀 
시간이 없었다. 다행히도, 버추얼 강의의 숙제 제출은 인터넷 창의 빈 칸에 
수들을 입력하는 식이다. 각 칸에는 
$-999$ 이상 
$999$ 이하의 정수만 입력할 수 있다. 수현이가 버추얼 친구들을 만나러 
버추얼 세계로 떠날 수 있게 도와주자.
'''

a = list(map(int, input().split()))
# a, b, c, d, e, f

for x in range(-1000, 1001):
    if a[4] != 0:
        if a[0]*x + a[1]*((a[5]-a[3]*x)/a[4]) == a[2]:
            y = int(((a[5]-a[3]*x)/a[4]))
            print(x, y)
            break
    else:                            # e가 0일때, 혹은 나머지도 0일때와 아닐 때를 구분해야 할듯. 식이 성립이 될지
        if a[0] != 0:
            if (a[0]*a[5])/a[3] + a[1]*x == a[2]:  # 여기서 위의 코드에서 분모가 되는 e가 0일때의 분기를 만들고,
                # 또 식을 세울 때 분모가 되는 a가 0이 될때와 안될 때 분기를 나눈 뒤
                y = int((a[2] - a[1]*x)/a[0])
                # 코드를 작성하니, 이제는 런타임 에러가 아닌 틀렸다는 결과가 나옴.
                print(y, x)
                break                             # 접근은 괜찮은데, 식이 잘못되었다는 뜻인가?
            else:
                x = int(a[5]/a[3])
                y = int(a[2]/a[1])
                print(x, y)


# 역시 브루탈포스고, -999 <= x, y <= 999의 범위임을 감안할 때
# 그냥 저 범위 안에서 한무반복 돌리는게 답에 가장 가까워 보이긴함.
# 두 번 돌 필요도 없이, x 하나만 나와도 방정식에 대입하면 y는 자동으로 나오니.

# 그냥 연립방정식을 x 단일로 풀어쓰고 -999부터 999까지 대입하면 꼴이 이상하게 남을 확인.
# 런타임 에러라고 뜨는데, 뭐에서 반례가 생기는지 모르겠다. 시간이 너무 오래 걸린다거나?
# 근데 그런것 치곤 한문제당 넘어가는 시간은 짧아보인다. 대략 75퍼에서 실패
# 찾아보니, 밑의 식을 정리하면 y = (f-dx)/e 인데, e가 0이 되면 문제일 수도 있겠음.
